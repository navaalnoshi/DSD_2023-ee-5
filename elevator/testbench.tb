`timescale 1ns / 1ps

module elevator_tb();

    // Inputs
    logic        direction;
    logic [2:0]  req_floor;
    logic        clk;
    logic        reset;
    logic        emergency;
    logic        valid_in;

    // Outputs
    logic [6:0]  cathode;
    logic [7:0]  anode;
    logic        r;
    logic        g;
    logic        b;

    // Instantiate the Unit Under Test (UUT)
    elevator UUT (
        .direction(direction),
        .req_floor(req_floor),
        .clk(clk),
        .reset(reset),
        .emergency(emergency),
        .valid_in(valid_in),
        .cathode(cathode),
        .anode(anode),
        .r(r),
        .g(g),
        .b(b)
    );

    // Clock generator
    initial begin
        clk <= 1'b0;
        forever #5 clk <= ~clk;
    end

    // Reset task
    task reseter;
        reset <= 0;
        @(posedge clk);
        reset <= #1 1;
        @(posedge clk);
        reset <= #1 0;
    endtask

    // Task to toggle valid_in
    task valid_toggler;
        @(posedge clk);
        valid_in <= #1 ~valid_in;
    endtask

    // Task to drive inputs
    task driver(input logic dir, input logic [2:0] floor, input logic emerg = 0);
        @(posedge clk);
        direction <= #1 dir;
        req_floor <= #1 floor;
        emergency <= #1 emerg;
        valid_in <= #1 1;
        @(posedge clk);
        valid_in <= #1 0;
    endtask

    // Function to decode anode based on current floor
    function [7:0] anode_decoder(input logic [2:0] floor);
        logic [7:0] anode_out;
        case(floor)
            3'b000: anode_out = 8'b11111110;
            3'b001: anode_out = 8'b11111101;
            3'b010: anode_out = 8'b11111011;
            3'b011: anode_out = 8'b11110111;
            3'b100: anode_out = 8'b11101111;
            3'b101: anode_out = 8'b11011111;
            3'b110: anode_out = 8'b10111111;
            3'b111: anode_out = 8'b01111111;
        endcase
        return anode_out;
    endfunction

    // Function to decode cathode based on current floor
    function [6:0] cathode_decoder(input logic [2:0] floor);
        logic [6:0] cathode_out;
        case(floor)
            3'b000: cathode_out = 7'b0000001;
            3'b001: cathode_out = 7'b1001111;
            3'b010: cathode_out = 7'b0010010;
            3'b011: cathode_out = 7'b0000110;
            3'b100: cathode_out = 7'b1001100;
            3'b101: cathode_out = 7'b0100100;
            3'b110: cathode_out = 7'b0100000;
            3'b111: cathode_out = 7'b0001111;
        endcase
        return cathode_out;
    endfunction

    // Function to predict RGB LEDs based on state
    function [2:0] rgb_decoder(input logic [2:0] state);
        logic r_exp, g_exp, b_exp;
        r_exp = 0;
        g_exp = 0;
        b_exp = 0;
        case(state)
            3'd0: begin // RESET
                r_exp = 0; g_exp = 0; b_exp = 0;
            end
            3'd1: begin // IDLE
                r_exp = 0; g_exp = 1; b_exp = 0;
            end
            3'd2: begin // MOVING_UP
                r_exp = 0; g_exp = 0; b_exp = 1;
            end
            3'd3: begin // MOVING_DOWN
                r_exp = 1; g_exp = 1; b_exp = 0;
            end
            3'd4: begin // DOOR_OPEN
                r_exp = 0; g_exp = 1; b_exp = 1;
            end
            3'd5: begin // DOOR_CLOSE
                r_exp = 1; g_exp = 0; b_exp = 1;
            end
            3'd6: begin // EMERGENCY
                r_exp = 1; g_exp = 0; b_exp = 0;
            end
            default: begin
                r_exp = 0; g_exp = 0; b_exp = 0;
            end
        endcase
        return {r_exp, g_exp, b_exp};
    endfunction

    // Monitor task to check outputs
    task monitor;
        logic [7:0] expected_anode;
        logic [6:0] expected_cathode;
        logic [2:0] expected_rgb;
        logic r_exp, g_exp, b_exp;
        @(posedge clk);
        expected_anode = anode_decoder(UUT.current_floor);
        expected_cathode = cathode_decoder(UUT.current_floor);
        expected_rgb = rgb_decoder(UUT.current_state);
        {r_exp, g_exp, b_exp} = expected_rgb;

        // Check anode
        if (expected_anode != anode)
            $display("Error-In-Anode: Current Floor = %d, Expected Anode Output = %b, Got = %b", UUT.current_floor, expected_anode, anode);
        else
            $display("Anode-Pass: Current Floor = %d, Got = %b", UUT.current_floor, anode);

        // Check cathode
        if (expected_cathode != cathode)
            $display("Error-In-Cathode: Current Floor = %d, Expected Cathode Output = %b, Got = %b", UUT.current_floor, expected_cathode, cathode);
        else
            $display("Cathode-Pass: Current Floor = %d, Got = %b", UUT.current_floor, cathode);

        // Check RGB LEDs
        if ({r, g, b} != {r_exp, g_exp, b_exp})
            $display("Error-In-RGB: State = %d, Expected RGB = %b, Got = %b", UUT.current_state, {r_exp, g_exp, b_exp}, {r, g, b});
        else
            $display("RGB-Pass: State = %d, Got = %b", UUT.current_state, {r, g, b});
    endtask

    // Modify COUNT_20S and COUNT_1S for simulation
    initial begin
        UUT.COUNT_20S = 20;  // Reduce to 20 clock cycles for simulation
        UUT.COUNT_1S = 10;   // Reduce to 10 clock cycles for simulation
    end

    // Test sequence
    initial begin
        // Initialize inputs
        direction = 0;
        req_floor = 0;
        emergency = 0;
        valid_in = 0;

        // Reset the module
        reseter;

        // Test 1: Request floor 3 (up) from floor 0
        $display("Test 1: Requesting floor 3 (up) from floor 0");
        driver(1, 3'd3, 0);  // direction = 1 (up), req_floor = 3
        repeat(50) begin
            monitor();
            @(posedge clk);
        end

        // Test 2: Request floor 1 (down) from floor 3
        $display("Test 2: Requesting floor 1 (down) from floor 3");
        driver(0, 3'd1, 0);  // direction = 0 (down), req_floor = 1
        repeat(50) begin
            monitor();
            @(posedge clk);
        end

        // Test 3: Trigger emergency mode
        $display("Test 3: Triggering emergency mode");
        driver(1, 3'd4, 1);  // direction = 1, req_floor = 4, emergency = 1
        repeat(10) begin
            monitor();
            @(posedge clk);
        end

        // Test 4: Clear emergency and return to idle
        $display("Test 4: Clearing emergency");
        driver(1, 3'd4, 0);  // emergency = 0
        repeat(20) begin
            monitor();
            @(posedge clk);
        end

        // Test 5: Multiple requests (floor 5 up, then floor 2 down)
        $display("Test 5: Multiple requests (floor 5 up, then floor 2 down)");
        driver(1, 3'd5, 0);  // Request floor 5 (up)
        repeat(50) begin
            monitor();
            @(posedge clk);
        end
        driver(0, 3'd2, 0);  // Request floor 2 (down)
        repeat(50) begin
            monitor();
            @(posedge clk);
        end

        $display("Testbench completed.");
        $finish;
    end

endmodule
